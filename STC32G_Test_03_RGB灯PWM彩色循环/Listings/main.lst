C251 COMPILER V5.60.0,  main                                                               26/03/24  19:09:29  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE main.c XSMALL INTR2 BROWSE DEBUG PRINT(.\Listings\main.lst) TABS(2) OB
                    -JECT(.\Objects\main.obj) 

stmt  level    source

    1          #include <STC32G.h>
    2          
    3          #define PWM1_0      0x00  //P:P1.0  N:P1.1
    4          #define PWM1_1      0x01  //P:P2.0  N:P2.1
    5          #define PWM1_2      0x02  //P:P6.0  N:P6.1
    6          
    7          #define PWM2_0      0x00  //P:P1.2/P5.4  N:P1.3
    8          #define PWM2_1      0x04  //P:P2.2  N:P2.3
    9          #define PWM2_2      0x08  //P:P6.2  N:P6.3
   10          
   11          #define PWM3_0      0x00  //P:P1.4  N:P1.5
   12          #define PWM3_1      0x10  //P:P2.4  N:P2.5
   13          #define PWM3_2      0x20  //P:P6.4  N:P6.5
   14          
   15          #define PWM4_0      0x00  //P:P1.6  N:P1.7
   16          #define PWM4_1      0x40  //P:P2.6  N:P2.7
   17          #define PWM4_2      0x80  //P:P6.6  N:P6.7
   18          #define PWM4_3      0xC0  //P:P3.4  N:P3.3
   19          
   20          #define ENO1P       0x01
   21          #define ENO1N       0x02
   22          #define ENO2P       0x04
   23          #define ENO2N       0x08
   24          #define ENO3P       0x10
   25          #define ENO3N       0x20
   26          #define ENO4P       0x40
   27          #define ENO4N       0x80
   28          
   29          // #define MAIN_Fosc 24000000UL    // ä¸»é¢‘ï¼Œæœ¬å®ä¾‹ä¸­ä¸éœ€è¦
   30          
   31          // å®šä¹‰æŒ‰é”®å¼•è„š
   32          sbit key1 = P2^0;
   33          sbit key2 = P2^1;
   34          sbit key3 = P2^2;
   35          sbit key4 = P2^3;
   36          
   37          // å®šä¹‰LEDå¼•è„š
   38          sbit led_vcc_green = P5^0;
   39          sbit led_vcc_red = P5^1;
   40          sbit led_vcc_blue = P5^2;
   41          
   42          unsigned int pwma_1_duty;
   43          unsigned int pwma_2_duty;
   44          unsigned int pwma_3_duty;
   45          bit pwma_1_flag;
   46          bit pwma_2_flag;
   47          bit pwma_3_flag;
   48          
   49          unsigned char led_power = 0; // LED ç”µæºçŠ¶æ€ï¼Œ0ä¸ºå…³é—­ï¼Œ1ä¸ºå¼€å¯
   50          
   51          unsigned int led_color_gradient_interval = 1000; // LED å½©è‰²æ¸å˜å‘¨æœŸé•¿åº¦ï¼Œå•ä½ä¸ºæ¯«ç§’
   52          unsigned int led_color_gradient_interval_index = 0; // LED å½©è‰²æ¸å˜å‘¨æœŸé•¿åº¦ç´¢å¼•ï¼Œç”¨äºé€‰æ‹©æ
             -•°ç»„ä¸­çš„æŸä¸ªå€¼
   53          unsigned int led_color_gradient_intervals[7] = {100, 200, 500, 750, 1000, 2000, 3000}; // LED å½©è‰²æ¸å
             -˜å‘¨æœŸé•¿åº¦ï¼Œå•ä½ä¸ºæ¯«ç§’
   54          
   55          unsigned char key1_up_store = 1; // æŒ‰é”®1çŠ¶æ€æš‚å­˜
   56          unsigned char key2_up_store = 1; // æŒ‰é”®2çŠ¶æ€æš‚å­˜
C251 COMPILER V5.60.0,  main                                                               26/03/24  19:09:29  PAGE 2   

   57          unsigned char key3_up_store = 1; // æŒ‰é”®3çŠ¶æ€æš‚å­˜
   58          unsigned char key4_up_store = 1; // æŒ‰é”®4çŠ¶æ€æš‚å­˜
   59          
   60          unsigned char led_rgb_mode = 0; // RGB LEDç¯å…‰æ¨¡å¼ï¼Œ0ä¸ºç™½å…‰å¸¸äº®ï¼Œ1ä¸ºä¸‰åŸè‰²å¾ªç¯ï¼Œ2ä¸ºå½©
             -è‰²æ¸å˜å¾ªç¯
   61          
   62          // è®¡æ•°å™¨è¦ä½¿ç”¨intç±»å‹ï¼Œå¦‚æœä½¿ç”¨char(æœ€å¤§å€¼255)ä¼šæº¢å‡ºï¼Œå¯¼è‡´åŠŸèƒ½å¼‚å¸¸
   63          unsigned int timer0_counter = 0; // LEDæµæ°´è®¡æ•°å™¨
   64          
   65          void key1_short_press()
   66          {
   67   1          // çŸ­æŒ‰é”®1åŠŸèƒ½ï¼šå…³é—­RGBç¯
   68   1          led_power = 0;
   69   1      }
   70          
   71          void key2_short_press()
   72          {
   73   1          // çŸ­æŒ‰é”®2åŠŸèƒ½ï¼šæ‰“å¼€RGBç¯
   74   1          led_power = 1;
   75   1      }
   76          
   77          void key3_short_press()
   78          {
   79   1          // çŸ­æŒ‰é”®3åŠŸèƒ½ï¼šåˆ‡æ¢LEDç¯æ¨¡å¼ã€ç™½å…‰å‘¼å¸/å½©è‰²å¾ªç¯/ä¸ƒå½©é—ªçƒã€‘
   80   1          led_rgb_mode++;
   81   1          if(led_rgb_mode > 2)
   82   1          {
   83   2              led_rgb_mode = 0;
   84   2          }
   85   1      }
   86          
   87          void key4_short_press()
   88          {
   89   1          // çŸ­æŒ‰é”®4åŠŸèƒ½ï¼šæ›´æ”¹LEDå˜åŒ–çš„é€Ÿåº¦0
   90   1          led_color_gradient_interval_index++;
   91   1          led_color_gradient_interval = led_color_gradient_intervals[led_color_gradient_interval_index % 7];
   92   1          if (led_color_gradient_interval_index >= 7)
   93   1          {
   94   2              led_color_gradient_interval_index = 0;
   95   2          }
   96   1      }
   97          
   98          void key1_check() 
   99          {
  100   1          if(key1 == 0 && key1_up_store == 1)
  101   1          {
  102   2              key1_up_store = 0; // æ ‡è®°æŒ‰é”®è¢«æŒ‰ä¸‹
  103   2          }
  104   1          if(key1 == 1 && key1_up_store == 0)
  105   1          {
  106   2              key1_up_store = 1; // æ ‡è®°æŒ‰é”®è¢«é‡Šæ”¾
  107   2              key1_short_press(); // è§¦å‘çŸ­æŒ‰é”®1åŠŸèƒ½
  108   2          }
  109   1      }
  110          
  111          void key2_check()
  112          {
  113   1          if(key2 == 0 && key2_up_store == 1)
  114   1          {
  115   2              key2_up_store = 0; // æ ‡è®°æŒ‰é”®è¢«æŒ‰ä¸‹
  116   2          }
  117   1          if(key2 == 1 && key2_up_store == 0)
  118   1          {
  119   2              key2_up_store = 1; // æ ‡è®°æŒ‰é”®è¢«é‡Šæ”¾
  120   2              key2_short_press(); // è§¦å‘çŸ­æŒ‰é”®2åŠŸèƒ½
  121   2          }
C251 COMPILER V5.60.0,  main                                                               26/03/24  19:09:29  PAGE 3   

  122   1      }
  123          
  124          void key3_check()
  125          {
  126   1          if(key3 == 0 && key3_up_store == 1)
  127   1          {
  128   2              key3_up_store = 0; // æ ‡è®°æŒ‰é”®è¢«æŒ‰ä¸‹
  129   2          }
  130   1          if(key3 == 1 && key3_up_store == 0)
  131   1          {
  132   2              key3_up_store = 1; // æ ‡è®°æŒ‰é”®è¢«é‡Šæ”¾
  133   2              key3_short_press(); // è§¦å‘çŸ­æŒ‰é”®3åŠŸèƒ½
  134   2          }
  135   1      }
  136          
  137          void key4_check()
  138          {
  139   1          if(key4 == 0 && key4_up_store == 1)
  140   1          {
  141   2              key4_up_store = 0; // æ ‡è®°æŒ‰é”®è¢«æŒ‰ä¸‹
  142   2          }
  143   1          if(key4 == 1 && key4_up_store == 0)
  144   1          {
  145   2              key4_up_store = 1; // æ ‡è®°æŒ‰é”®è¢«é‡Šæ”¾
  146   2              key4_short_press(); // è§¦å‘çŸ­æŒ‰é”®4åŠŸèƒ½
  147   2          }
  148   1      }
  149          
  150          void led_mode_2_color_gradient()
  151          {
  152   1          
  153   1      }
  154          
  155          // å»¶æ—¶å‡½æ•°ï¼Œæœ¬å®ä¾‹ä¸­æœªä½¿ç”¨
  156          // void delay_ms(unsigned char ms)
  157          // {
  158          //      unsigned int i;
  159          //      do{
  160          //           i = MAIN_Fosc / 6000;
  161          //           while(--i);
  162          //      }while(--ms);
  163          // }
  164          
  165          void pwma_init(void)
  166          {
  167   1          // è¾“å‡ºé¢‘ç‡è®¡ç®—ï¼š(SYS_CLOCK) / (PSCR+1) / (ARR+1) = 24.0KHz
  168   1          // è¾“å‡ºå ç©ºæ¯”è®¡ç®—ï¼š(CCR) / (ARR+1) * 100% = 50%
  169   1      
  170   1          // 1.é€‰æ‹©æ—¶é’Ÿæºï¼ˆé»˜è®¤24.0MHzï¼‰
  171   1          // 2.æ—¶åŸºå•å…ƒ
  172   1          PWMA_PSCRH = 0x00;  // é«˜ä½ä½éƒ½æ˜¯0ï¼Œ1åˆ†é¢‘ï¼ˆä¸æ”¹å˜ï¼‰
  173   1          PWMA_PSCRL = 0x00;
  174   1      
  175   1          // 3.è¾“å…¥è¾“å‡ºå¼•è„šé…ç½®
  176   1          PWMA_ENO = 0x00;        // æ¸…é›¶
  177   1          PWMA_ENO |= ENO1P;      //ä½¿èƒ½è¾“å‡º
  178   1          PWMA_ENO |= ENO1N;      //ä½¿èƒ½è¾“å‡º
  179   1          PWMA_ENO |= ENO2P;      //ä½¿èƒ½è¾“å‡º
  180   1          PWMA_ENO |= ENO2N;      //ä½¿èƒ½è¾“å‡º
  181   1          PWMA_ENO |= ENO3P;      //ä½¿èƒ½è¾“å‡º
  182   1          PWMA_ENO |= ENO3N;      //ä½¿èƒ½è¾“å‡º
  183   1      
  184   1          PWMA_PS = 0x00;         //é«˜çº§ PWM é€šé“è¾“å‡ºè„šé€‰æ‹©ä½
  185   1          PWMA_PS |= PWM1_2;      //é€‰æ‹© PWM1_2 é€šé“
  186   1          PWMA_PS |= PWM2_2;      //é€‰æ‹© PWM2_2 é€šé“
  187   1          PWMA_PS |= PWM3_2;      //é€‰æ‹© PWM3_2 é€šé“
C251 COMPILER V5.60.0,  main                                                               26/03/24  19:09:29  PAGE 4   

  188   1          PWMA_PS |= PWM4_2;      //é€‰æ‹© PWM4_2 é€šé“
  189   1      
  190   1          // 4.è¾“å…¥è¾“å‡ºæ¨¡å¼è®¾ç½®
  191   1          PWMA_CCER1 = 0x00; //å†™ CCMRx å‰å¿…é¡»å…ˆæ¸…é›¶ CCxE å…³é—­é€šé“
  192   1          PWMA_CCER2 = 0x00;
  193   1          PWMA_CCMR1 = 0x68; //é€šé“æ¨¡å¼é…ç½®
  194   1          PWMA_CCMR2 = 0x68;
  195   1          PWMA_CCMR3 = 0x68;
  196   1          PWMA_CCMR4 = 0x68;
  197   1          PWMA_CCER1 = 0x55; //é…ç½®é€šé“è¾“å‡ºä½¿èƒ½å’Œææ€§
  198   1          PWMA_CCER2 = 0x55;
  199   1      
  200   1          PWMA_ARRH = (unsigned char)(led_color_gradient_interval >> 8); //è®¾ç½®å‘¨æœŸæ—¶é—´
  201   1          PWMA_ARRL = (unsigned char)led_color_gradient_interval;
  202   1      
  203   1          PWMA_BKR = 0x80;        // ä½¿èƒ½ä¸»è¾“å‡º
  204   1      
  205   1          PWMA_CR1 = 1;           // ä½¿èƒ½ARRé¢„è£…è½½, å¼€å§‹è®¡æ—¶
  206   1      }
  207          
  208          void pwm_duty_update(void)
  209          {
  210   1          PWMA_CCR1H = (unsigned char)(pwma_1_duty >> 8); //è®¾ç½®å ç©ºæ¯”æ—¶é—´
  211   1          PWMA_CCR1L = (unsigned char)(pwma_1_duty);
  212   1          PWMA_CCR2H = (unsigned char)(pwma_2_duty >> 8); //è®¾ç½®å ç©ºæ¯”æ—¶é—´
  213   1          PWMA_CCR2L = (unsigned char)(pwma_2_duty);
  214   1          PWMA_CCR3H = (unsigned char)(pwma_3_duty >> 8); //è®¾ç½®å ç©ºæ¯”æ—¶é—´
  215   1          PWMA_CCR3L = (unsigned char)(pwma_3_duty);
  216   1      }
  217          
  218          void timer0_isr(void) interrupt 1
  219          {
  220   1          // pwma_1 æ˜¯ P6.0ï¼Œpwma_2 æ˜¯ P6.2ï¼Œpwma_3 æ˜¯ P6.4
  221   1          // è“è‰²            ç»¿è‰²            çº¢è‰²
  222   1          static int state = 0;
  223   1      
  224   1          timer0_counter++;
  225   1      
  226   1          switch (state)
  227   1          {
  228   2              case 0: // çº¢è‰²åˆ°é»„è‰²
  229   2                  if (pwma_2_duty < led_color_gradient_interval)
  230   2                  {
  231   3                      pwma_2_duty++;
  232   3                  }
  233   2                  else
  234   2                  {
  235   3                      state = 1;
  236   3                  }
  237   2                  break;
  238   2              case 1: // é»„è‰²åˆ°ç»¿è‰²
  239   2                  if (pwma_3_duty > 0)
  240   2                  {
  241   3                      pwma_3_duty--;
  242   3                  }
  243   2                  else
  244   2                  {
  245   3                      state = 2;
  246   3                  }
  247   2                  break;
  248   2              case 2: // ç»¿è‰²åˆ°é’è‰²
  249   2                  if (pwma_1_duty < led_color_gradient_interval)
  250   2                  {
  251   3                      pwma_1_duty++;
  252   3                  }
  253   2                  else
C251 COMPILER V5.60.0,  main                                                               26/03/24  19:09:29  PAGE 5   

  254   2                  {
  255   3                      state = 3;
  256   3                  }
  257   2                  break;
  258   2              case 3: // é’è‰²åˆ°è“è‰²
  259   2                  if (pwma_2_duty > 0)
  260   2                  {
  261   3                      pwma_2_duty--;
  262   3                  }
  263   2                  else
  264   2                  {
  265   3                      state = 4;
  266   3                  }
  267   2                  break;
  268   2              case 4: // è“è‰²åˆ°ç´«è‰²
  269   2                  if (pwma_3_duty < led_color_gradient_interval)
  270   2                  {
  271   3                      pwma_3_duty++;
  272   3                  }
  273   2                  else
  274   2                  {
  275   3                      state = 5;
  276   3                  }
  277   2                  break;
  278   2              case 5: // ç´«è‰²åˆ°çº¢è‰²
  279   2                  if (pwma_1_duty > 0)
  280   2                  {
  281   3                      pwma_1_duty--;
  282   3                  }
  283   2                  else
  284   2                  {
  285   3                      state = 0;
  286   3                  }
  287   2                  break;
  288   2          }
  289   1      
  290   1          pwm_duty_update();
  291   1      }
  292          
  293          
  294          void timer0_init(void)    //0.1æ¯«ç§’@24.000M å¯¹åº” PWMé¢‘ç‡5000Hz
  295          {
  296   1        AUXR |= 0x80;     //å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
  297   1        TMOD &= 0xF0;     //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
  298   1        TL0 = 0xA0;       //è®¾ç½®å®šæ—¶åˆå§‹å€¼
  299   1        TH0 = 0xF6;       //è®¾ç½®å®šæ—¶åˆå§‹å€¼
  300   1        TF0 = 0;        //æ¸…é™¤TF0æ ‡å¿—
  301   1        TR0 = 1;        //å®šæ—¶å™¨0å¼€
  302   1        ET0 = 1;        //ä½¿èƒ½å®šæ—¶å™¨0ä¸­æ–­
  303   1          EA = 1;           //ä½¿èƒ½æ€»ä¸­æ–­
  304   1      }
  305          void main(void)
  306          {
  307   1          WTST = 0;  //è®¾ç½®ç¨‹åºæŒ‡ä»¤å»¶æ—¶å‚æ•°ï¼Œèµ‹å€¼ä¸º0å¯å°†CPUæ‰§è¡ŒæŒ‡ä»¤çš„é€Ÿåº¦è®¾ç½®ä¸ºæœ€å¿«
  308   1          EAXFR = 1; //æ‰©å±•å¯„å­˜å™¨(XFR)è®¿é—®ä½¿èƒ½
  309   1          CKCON = 0; //æé«˜è®¿é—®XRAMé€Ÿåº¦
  310   1      
  311   1          P5M0 = 0xff; P5M1 = 0x00;           //é…ç½®P5ä¸ºè¾“å‡ºæ¨¡å¼
  312   1          P2M0 = 0x00; P2M1 = 0x00;           //é…ç½®P2ä¸ºå‡†åŒå‘æ¨¡å¼
  313   1      
  314   1          pwma_init();                        //åˆå§‹åŒ–PWM
  315   1          timer0_init();                      //åˆå§‹åŒ–å®šæ—¶å™¨0
  316   1          while(1)
  317   1          {
  318   2              // æ£€æµ‹æŒ‰é”®
  319   2              key1_check();
C251 COMPILER V5.60.0,  main                                                               26/03/24  19:09:29  PAGE 6   

  320   2              key2_check();
  321   2              key3_check();
  322   2              key4_check();
  323   2          }
  324   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       792     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        34     ------
  bit size             =         3     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        72     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
