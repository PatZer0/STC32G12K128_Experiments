C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      08/04/24  13:47:31  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_DL1B
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_DL1B.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\..\Libraries\seekfree_peripheral\SEEKFREE_DL1B.c XSMALL INTR2 WARNI
                    -NGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\
                    -seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;..\..\Libraries\seekfree_components) DEBUG PRINT(.\Out_File\SEEKFREE
                    -_DL1B.lst) TABS(2) OBJECT(.\Out_File\SEEKFREE_DL1B.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * MM32F527X-E9P Opensourec Library å³ï¼ˆMM32F527X-E9P å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬
             -ä¸‰æ–¹å¼€æºåº“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯ MM32F527X-E9P å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * MM32F527X-E9P å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          zf_device_dl1b
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK 5.37
   28          * é€‚ç”¨å¹³å°          MM32F527X_E9P
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…                å¤‡æ³¨
   33          * 2022-08-10        Teternal            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   SCL                 æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_SCL_PIN  å®å®šä¹‰
   40          *                   SDA                 æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_SDA_PIN  å®å®šä¹‰
   41          *                   XS                  æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_XS_PIN  å®å®šä¹‰
   42          *                   VCC                 5V ç”µæº
   43          *                   GND                 ç”µæºåœ°
   44          *                   ------------------------------------
   45          *********************************************************************************************************
             -***********/
   46          
   47          #include "zf_delay.h"
   48          #include "SEEKFREE_DL1B.h"
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      08/04/24  13:47:31  PAGE 2   

   49          #include "SEEKFREE_CONFIG.h"
   50          
   51          uint8 dl1b_init_flag = 0;
   52          uint8 dl1b_finsh_flag = 0;
   53          uint16 dl1b_distance_mm = 8192;
   54          
   55          
   56          
   57          #define dl1b_transfer_8bit_array(tdata, tlen, rdata, rlen)      (dl1b_iic_transfer_8bit_array((tdata), (t
             -len), (rdata), (rlen)))
   58          
   59          
   60          #define GET_DL1B_SDA          DL1B_SDA_PIN
   61          #define DL1B_SDA_LOW()            DL1B_SDA_PIN = 0    //IOå£è¾“å‡ºä½ç”µå¹³
   62          #define DL1B_SDA_HIGH()           DL1B_SDA_PIN = 1    //IOå£è¾“å‡ºé«˜ç”µå¹³
   63          
   64          #define DL1B_SCL_LOW()            DL1B_SCL_PIN = 0    //IOå£è¾“å‡ºä½ç”µå¹³
   65          #define DL1B_SCL_HIGH()           DL1B_SCL_PIN = 1    //IOå£è¾“å‡ºé«˜ç”µå¹³
   66          
   67          #define ack 1      //ä¸»åº”ç­”
   68          #define no_ack 0   //ä»åº”ç­”  
   69          
   70          //-------------------------------------------------------------------------------------------------------
             -------------
   71          //  @brief      æ¨¡æ‹ŸIICå»¶æ—¶
   72          //  @return     void
   73          //  @since      v1.0
   74          //  Sample usage:       å¦‚æœIICé€šè®¯å¤±è´¥å¯ä»¥å°è¯•å¢åŠ jçš„å€¼
   75          //-------------------------------------------------------------------------------------------------------
             -------------
   76          static void dl1b_simiic_delay(void)
   77          {
   78   1          uint16 xdata j=DL1B_SOFT_IIC_DELAY;
   79   1          while(j--);
   80   1      }
   81          
   82          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   83          static void dl1b_simiic_start(void)
   84          {
   85   1          DL1B_SDA_HIGH();
   86   1          DL1B_SCL_HIGH();
   87   1          dl1b_simiic_delay();
   88   1          DL1B_SDA_LOW();
   89   1          dl1b_simiic_delay();
   90   1          DL1B_SCL_LOW();
   91   1      }
   92          
   93          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   94          static void dl1b_simiic_stop(void)
   95          {
   96   1          DL1B_SDA_LOW();
   97   1          DL1B_SCL_LOW();
   98   1          dl1b_simiic_delay();
   99   1          DL1B_SCL_HIGH();
  100   1          dl1b_simiic_delay();
  101   1          DL1B_SDA_HIGH();
  102   1          dl1b_simiic_delay();
  103   1      }
  104          
  105          //ä¸»åº”ç­”(åŒ…å«ack:SDA=0å’Œno_ack:SDA=0)
  106          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  107          static void dl1b_simiic_sendack(unsigned char ack_dat)
  108          {
  109   1          DL1B_SCL_LOW();
  110   1          dl1b_simiic_delay();
  111   1          if(ack_dat) DL1B_SDA_LOW();
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      08/04/24  13:47:31  PAGE 3   

  112   1          else      DL1B_SDA_HIGH();
  113   1          DL1B_SCL_HIGH();
  114   1          dl1b_simiic_delay();
  115   1          DL1B_SCL_LOW();
  116   1          dl1b_simiic_delay();
  117   1      }
  118          
  119          
  120          static int dl1b_sccb_waitack(void)
  121          {
  122   1          DL1B_SCL_LOW();
  123   1          dl1b_simiic_delay();
  124   1          DL1B_SCL_HIGH();
  125   1          dl1b_simiic_delay();
  126   1          if(GET_DL1B_SDA)           //åº”ç­”ä¸ºé«˜ç”µå¹³ï¼Œå¼‚å¸¸ï¼Œé€šä¿¡å¤±è´¥
  127   1          {
  128   2              DL1B_SCL_LOW();
  129   2              return 0;
  130   2          }
  131   1          DL1B_SCL_LOW();
  132   1          dl1b_simiic_delay();
  133   1          return 1;
  134   1      }
  135          
  136          //å­—èŠ‚å‘é€ç¨‹åº
  137          //å‘é€c(å¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯æ˜¯åœ°å€)ï¼Œé€å®Œåæ¥æ”¶ä»åº”ç­”
  138          //ä¸è€ƒè™‘ä»åº”ç­”ä½
  139          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  140          static void dl1b_send_ch(uint8 c)
  141          {
  142   1          uint8 xdata i = 8;
  143   1          while(i--)
  144   1          {
  145   2              if(c & 0x80)  DL1B_SDA_HIGH();//SDA è¾“å‡ºæ•°æ®
  146   2              else      DL1B_SDA_LOW();
  147   2              c <<= 1;
  148   2              dl1b_simiic_delay();
  149   2              DL1B_SCL_HIGH();                //SCL æ‹‰é«˜ï¼Œé‡‡é›†ä¿¡å·
  150   2              dl1b_simiic_delay();
  151   2              DL1B_SCL_LOW();                //SCL æ—¶é’Ÿçº¿æ‹‰ä½
  152   2          }
  153   1          dl1b_sccb_waitack();
  154   1      }
  155          
  156          
  157          //å­—èŠ‚æ¥æ”¶ç¨‹åº
  158          //æ¥æ”¶å™¨ä»¶ä¼ æ¥çš„æ•°æ®ï¼Œæ­¤ç¨‹åºåº”é…åˆ|ä¸»åº”ç­”å‡½æ•°|ä½¿ç”¨
  159          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  160          static uint8 dl1b_read_ch(uint8 ack_x)
  161          {
  162   1          uint8 xdata i;
  163   1          uint8 xdata c;
  164   1          c=0;
  165   1          DL1B_SCL_LOW();
  166   1          dl1b_simiic_delay();
  167   1          DL1B_SDA_HIGH();
  168   1          for(i=0; i<8; i++)
  169   1          {
  170   2              dl1b_simiic_delay();
  171   2              DL1B_SCL_LOW();         //ç½®æ—¶é’Ÿçº¿ä¸ºä½ï¼Œå‡†å¤‡æ¥æ”¶æ•°æ®ä½
  172   2              dl1b_simiic_delay();
  173   2              DL1B_SCL_HIGH();         //ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ï¼Œä½¿æ•°æ®çº¿ä¸Šæ•°æ®æœ‰æ•ˆ
  174   2              dl1b_simiic_delay();
  175   2              c<<=1;
  176   2              if(GET_DL1B_SDA)
  177   2              {
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      08/04/24  13:47:31  PAGE 4   

  178   3                  c+=1;   //è¯»æ•°æ®ä½ï¼Œå°†æ¥æ”¶çš„æ•°æ®å­˜c
  179   3              }
  180   2          }
  181   1          DL1B_SCL_LOW();
  182   1          dl1b_simiic_delay();
  183   1          dl1b_simiic_sendack(ack_x);
  184   1          return c;
  185   1      }
  186          
  187          
  188          //-------------------------------------------------------------------------------------------------------
             -------------
  189          // å‡½æ•°ç®€ä»‹     è½¯ä»¶ IIC æ¥å£ä¼ è¾“ 8bit æ•°ç»„ å…ˆå†™åè¯»å–
  190          // å‚æ•°è¯´æ˜     *write_data     å‘é€æ•°æ®å­˜æ”¾ç¼“å†²åŒº
  191          // å‚æ•°è¯´æ˜     write_len       å‘é€ç¼“å†²åŒºé•¿åº¦
  192          // å‚æ•°è¯´æ˜     *read_data      è¯»å–æ•°æ®å­˜æ”¾ç¼“å†²åŒº
  193          // å‚æ•°è¯´æ˜     read_len        è¯»å–ç¼“å†²åŒºé•¿åº¦
  194          // è¿”å›å‚æ•°     void
  195          // ä½¿ç”¨ç¤ºä¾‹     iic_transfer_8bit_array(IIC_1, addr, data, 64, data, 64);
  196          // å¤‡æ³¨ä¿¡æ¯
  197          //-------------------------------------------------------------------------------------------------------
             -------------
  198          void dl1b_iic_transfer_8bit_array (const uint8 *write_data, uint32 write_len, uint8 *read_data, uint32 re
             -ad_len)
  199          {
  200   1          dl1b_simiic_start();
  201   1          dl1b_send_ch(DL1B_DEV_ADDR << 1);
  202   1          while(write_len --)
  203   1          {
  204   2              dl1b_send_ch(*write_data ++);
  205   2          }
  206   1          dl1b_simiic_start();
  207   1          dl1b_send_ch(DL1B_DEV_ADDR << 1 | 0x01);
  208   1          while(read_len --)
  209   1          {
  210   2              // å‰é¢7ä½éœ€è¦å›å¤ackï¼Œæœ€å1ä½ä¸éœ€è¦å›å¤ack.
  211   2              *read_data ++ = dl1b_read_ch(read_len != 0);
  212   2          }
  213   1          dl1b_simiic_stop();
  214   1      }
  215          
  216          
  217          
  218          
  219          
  220          //-------------------------------------------------------------------------------------------------------
             -------------
  221          // å‡½æ•°ç®€ä»‹     è¿”å›ä»¥æ¯«ç±³ä¸ºå•ä½çš„èŒƒå›´è¯»æ•°
  222          // å‚æ•°è¯´æ˜     void
  223          // è¿”å›å‚æ•°     void
  224          // ä½¿ç”¨ç¤ºä¾‹     dl1b_get_distance();
  225          // å¤‡æ³¨ä¿¡æ¯     åœ¨å¼€å§‹å•æ¬¡å°„ç¨‹æµ‹é‡åä¹Ÿè°ƒç”¨æ­¤å‡½æ•°
  226          //-------------------------------------------------------------------------------------------------------
             -------------
  227          void dl1b_get_distance (void)
  228          {
  229   1          if(dl1b_init_flag)
  230   1          {
  231   2              uint8 xdata data_buffer[3];
  232   2              int16 dl1b_distance_temp = 0;
  233   2              data_buffer[0] = DL1B_GPIO__TIO_HV_STATUS >> 8;
  234   2              data_buffer[1] = DL1B_GPIO__TIO_HV_STATUS & 0xFF;
  235   2              dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  236   2              if(data_buffer[2])
  237   2              {
  238   3                  data_buffer[0] = DL1B_SYSTEM__INTERRUPT_CLEAR >> 8;
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      08/04/24  13:47:31  PAGE 5   

  239   3                  data_buffer[1] = DL1B_SYSTEM__INTERRUPT_CLEAR & 0xFF;
  240   3                  data_buffer[2] = 0x01;
  241   3                  dl1b_transfer_8bit_array(data_buffer, 3, data_buffer, 0);// clear Interrupt
  242   3                  data_buffer[0] = DL1B_RESULT__RANGE_STATUS >> 8;
  243   3                  data_buffer[1] = DL1B_RESULT__RANGE_STATUS & 0xFF;
  244   3                  dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  245   3                  if(0x89 == data_buffer[2])
  246   3                  {
  247   4                      data_buffer[0] = DL1B_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0 >> 8;
  248   4                      data_buffer[1] = DL1B_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0 & 0xFF;
  249   4                      dl1b_transfer_8bit_array(data_buffer, 2, data_buffer, 2);
  250   4                      dl1b_distance_temp = data_buffer[0];
  251   4                      dl1b_distance_temp = (dl1b_distance_temp << 8) | data_buffer[1];
  252   4                      if(dl1b_distance_temp > 4000 || dl1b_distance_temp < 0)
  253   4                      {
  254   5                          dl1b_distance_mm = 8192;
  255   5                          dl1b_finsh_flag = 0;
  256   5                      }
  257   4                      else
  258   4                      {
  259   5                          dl1b_distance_mm = dl1b_distance_temp;
  260   5                          dl1b_finsh_flag = 1;
  261   5                      }
  262   4                  }
  263   3                  else
  264   3                  {
  265   4                      dl1b_distance_mm = 8192;
  266   4                      dl1b_finsh_flag = 0;
  267   4                  }
  268   3              }
  269   2              else
  270   2              {
  271   3                  dl1b_distance_mm = 8192;
  272   3                  dl1b_finsh_flag = 0;
  273   3              }
  274   2          }
  275   1      }
  276          
  277          
  278          
  279          //-------------------------------------------------------------------------------------------------------
             -------------
  280          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– DL1B
  281          // å‚æ•°è¯´æ˜     void
  282          // è¿”å›å‚æ•°     uint8 xdata           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  283          // ä½¿ç”¨ç¤ºä¾‹     dl1b_init();
  284          // å¤‡æ³¨ä¿¡æ¯
  285          //-------------------------------------------------------------------------------------------------------
             -------------
  286          uint8 dl1b_init (void)
  287          {
  288   1          uint8 xdata   return_state    = 0;
  289   1          uint8 xdata   data_buffer[2 + sizeof(dl1b_default_configuration)];
  290   1          uint16 xdata  time_out_count  = 0;
  291   1          do
  292   1          {
  293   2              delay_ms(50);
  294   2              DL1B_XS_PIN = 0;
  295   2              delay_ms(10);
  296   2              DL1B_XS_PIN = 1;
  297   2              delay_ms(50);
  298   2              data_buffer[0] = DL1B_FIRMWARE__SYSTEM_STATUS >> 8;
  299   2              data_buffer[1] = DL1B_FIRMWARE__SYSTEM_STATUS & 0xFF;
  300   2              dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  301   2              return_state = (0x01 == (data_buffer[2] & 0x01)) ? (0) : (1);
  302   2              if(1 == return_state)
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      08/04/24  13:47:31  PAGE 6   

  303   2              {
  304   3                  break;
  305   3              }
  306   2              data_buffer[0] = DL1B_I2C_SLAVE__DEVICE_ADDRESS >> 8;
  307   2              data_buffer[1] = DL1B_I2C_SLAVE__DEVICE_ADDRESS & 0xFF;
  308   2              memcpy(&data_buffer[2], (uint8 *)dl1b_default_configuration, sizeof(dl1b_default_configuration));
  309   2              dl1b_transfer_8bit_array(data_buffer, 2 + sizeof(dl1b_default_configuration), data_buffer, 0);
  310   2              while(1)
  311   2              {
  312   3                  data_buffer[0] = DL1B_GPIO__TIO_HV_STATUS >> 8;
  313   3                  data_buffer[1] = DL1B_GPIO__TIO_HV_STATUS & 0xFF;
  314   3                  dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  315   3                  if(0x00 == (data_buffer[2] & 0x01))
  316   3                  {
  317   4                      time_out_count = 0;
  318   4                      break;
  319   4                  }
  320   3                  if(DL1B_TIMEOUT_COUNT < time_out_count ++)
  321   3                  {
  322   4                      return_state = 1;
  323   4                      break;
  324   4                  }
  325   3                  delay_ms(1);
  326   3              }
  327   2              dl1b_init_flag = 1;
  328   2          }
  329   1          while(0);
  330   1          return return_state;
  331   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1089     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       148     ------
  xdata-const size     =    ------     ------
  edata size           =        25     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        16     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
